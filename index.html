<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flask Node-Flow Editor Prototype</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            height: 100%;
            margin: 0;
            overflow: hidden;
            background-color: #f3f4f6;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* æ ¼ç·šèƒŒæ™¯ */
        #canvas {
            width: 100%;
            height: 100%;
            position: relative;
            background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden;
            user-select: none;
        }

        /* SVG é€£ç·šå±¤ */
        svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* è®“é»æ“Šäº‹ä»¶ç©¿é€åˆ°ä¸‹å±¤ï¼Œé™¤éé»åˆ°ç·šæ¢ */
            z-index: 0;
        }

        .connection-line {
            fill: none;
            stroke: #64748b;
            stroke-width: 4px;
            stroke-linecap: round;
            pointer-events: stroke;
            cursor: pointer;
            transition: stroke 0.2s;
        }

        .connection-line:hover {
            stroke: #ef4444; /* åˆªé™¤æç¤ºè‰² */
        }

        /* ç¯€é»æ¨£å¼ */
        .node {
            position: absolute;
            width: 160px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: 1px solid #e2e8f0;
            z-index: 10;
            display: flex;
            flex-direction: column;
        }

        .node-header {
            padding: 8px 12px;
            background-color: #3b82f6;
            color: white;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            cursor: grab;
            font-weight: bold;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .node-header:active {
            cursor: grabbing;
        }

        .node-body {
            padding: 10px;
            font-size: 0.8rem;
            color: #475569;
        }

        /* é€£æ¥é» (Ports) */
        .port {
            width: 14px;
            height: 14px;
            background-color: #64748b;
            border: 2px solid white;
            border-radius: 50%;
            position: absolute;
            cursor: crosshair;
            z-index: 20;
            transition: transform 0.1s;
        }

        .port:hover {
            transform: scale(1.2);
            background-color: #3b82f6;
        }

        .port.input {
            top: 50%;
            left: -8px;
            transform: translateY(-50%);
        }

        .port.output {
            top: 50%;
            right: -8px;
            transform: translateY(-50%);
        }

        /* å´é‚Šæ¬„ */
        #sidebar {
            position: absolute;
            left: 20px;
            top: 20px;
            width: 220px;
            background: white;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            z-index: 50;
        }

        .draggable-item {
            background-color: #eff6ff;
            border: 1px solid #bfdbfe;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 6px;
            cursor: grab;
            font-size: 0.9rem;
            color: #1e40af;
            display: flex;
            align-items: center;
        }
        
        .draggable-item:hover {
            background-color: #dbeafe;
        }

        .icon {
            margin-right: 8px;
            font-size: 1.1rem;
        }

        /* æ§åˆ¶æŒ‰éˆ•å€ */
        #controls {
            position: absolute;
            right: 20px;
            top: 20px;
            z-index: 50;
            display: flex;
            gap: 10px;
        }

        /* é¡å‹é¡è‰² */
        .node.type-start .node-header { background-color: #10b981; }
        .node.type-process .node-header { background-color: #f59e0b; }
        .node.type-end .node-header { background-color: #ef4444; }

    </style>
</head>
<body>

    <!-- å·¥å…·æ¬„ -->
    <div id="sidebar">
        <h2 class="text-lg font-bold mb-4 text-slate-800">å…ƒä»¶åº«</h2>
        <div class="draggable-item" draggable="true" ondragstart="drag(event)" data-type="start" data-title="é–‹å§‹ (Start)">
            <span class="icon">ğŸš€</span> é–‹å§‹ç¯€é»
        </div>
        <div class="draggable-item" draggable="true" ondragstart="drag(event)" data-type="process" data-title="è³‡æ–™è™•ç† (Process)">
            <span class="icon">âš™ï¸</span> è™•ç†é‚è¼¯
        </div>
        <div class="draggable-item" draggable="true" ondragstart="drag(event)" data-type="process" data-title="API è«‹æ±‚ (Request)">
            <span class="icon">ğŸŒ</span> API è«‹æ±‚
        </div>
        <div class="draggable-item" draggable="true" ondragstart="drag(event)" data-type="end" data-title="çµæŸ (End)">
            <span class="icon">ğŸ</span> çµæŸè¼¸å‡º
        </div>
        
        <div class="mt-4 pt-4 border-t border-slate-200">
            <p class="text-xs text-slate-500">æç¤ºï¼šå¾å·¦å´æ‹–æ›³å…ƒä»¶åˆ°ç•«å¸ƒï¼Œé»æ“Šè¼¸å‡ºé»ä¸¦æ‹–æ›³åˆ°è¼¸å…¥é»é€²è¡Œé€£ç·šã€‚é»æ“Šé€£ç·šå¯åˆªé™¤ã€‚</p>
        </div>
    </div>

    <!-- é ‚éƒ¨æŒ‰éˆ• -->
    <div id="controls">
        <button onclick="exportFlow()" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded shadow transition">
            åŒ¯å‡º JSON (çµ¦ Flask)
        </button>
        <button onclick="runSimulation()" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded shadow transition">
            æ¨¡æ“¬åŸ·è¡Œ
        </button>
        <button onclick="clearCanvas()" class="bg-slate-600 hover:bg-slate-700 text-white px-4 py-2 rounded shadow transition">
            æ¸…ç©ºç•«å¸ƒ
        </button>
    </div>

    <!-- ä¸»ç•«å¸ƒ -->
    <div id="canvas" ondrop="drop(event)" ondragover="allowDrop(event)">
        <!-- SVG å±¤ç”¨æ–¼ç¹ªè£½é€£ç·š -->
        <svg id="connections-layer">
            <!-- å‹•æ…‹ç”Ÿæˆçš„é€£ç·šæœƒåœ¨é€™è£¡ -->
        </svg>
        <!-- ç¯€é»æœƒè¢«å‹•æ…‹æ·»åŠ åˆ°é€™è£¡ -->
    </div>

    <!-- æ¨¡æ“¬åŸ·è¡Œçµæœå½ˆçª— -->
    <div id="modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-[100] flex items-center justify-center">
        <div class="bg-white rounded-lg p-6 max-w-lg w-full shadow-2xl">
            <h3 class="text-xl font-bold mb-4">åŸ·è¡Œçµæœ / JSON è¼¸å‡º</h3>
            <pre id="modal-content" class="bg-slate-100 p-4 rounded overflow-auto max-h-60 text-sm font-mono"></pre>
            <div class="mt-4 flex justify-end">
                <button onclick="closeModal()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">é—œé–‰</button>
            </div>
        </div>
    </div>

    <script>
        // ç‹€æ…‹ç®¡ç†
        let nodes = [];
        let connections = [];
        let nextNodeId = 1;
        
        // æ‹–æ›³é€£ç·šç‹€æ…‹
        let isDrawing = false;
        let tempLine = null;
        let startPort = null;
        let dragSrcEl = null;

        // åˆå§‹åŒ–
        const canvas = document.getElementById('canvas');
        const svgLayer = document.getElementById('connections-layer');

        // --- 1. æ‹–æ”¾æ–°å¢ç¯€é»é‚è¼¯ ---
        function allowDrop(ev) {
            ev.preventDefault();
        }

        function drag(ev) {
            ev.dataTransfer.setData("type", ev.target.dataset.type);
            ev.dataTransfer.setData("title", ev.target.dataset.title);
        }

        function drop(ev) {
            ev.preventDefault();
            // ç¢ºä¿åªåœ¨ canvas æœ¬é«”ä¸Šæ”¾é–‹ï¼Œæˆ–å…¶å­å…ƒç´ å†’æ³¡
            const type = ev.dataTransfer.getData("type");
            const title = ev.dataTransfer.getData("title");
            
            if (type && title) {
                const rect = canvas.getBoundingClientRect();
                const x = ev.clientX - rect.left;
                const y = ev.clientY - rect.top;
                createNode(x, y, type, title);
            }
        }

        // --- 2. å»ºç«‹ç¯€é» DOM ---
        function createNode(x, y, type, title) {
            const id = `node-${nextNodeId++}`;
            const nodeEl = document.createElement('div');
            nodeEl.classList.add('node', `type-${type}`);
            nodeEl.id = id;
            nodeEl.style.left = `${x}px`;
            nodeEl.style.top = `${y}px`;

            // ç¯€é»å…§å®¹
            nodeEl.innerHTML = `
                <div class="node-header" onmousedown="startDragNode(event, '${id}')">
                    <span>${title}</span>
                    <span style="font-size:10px; opacity:0.7">ID:${nextNodeId-1}</span>
                </div>
                <div class="node-body">
                    è¨­å®šåƒæ•¸...
                </div>
            `;

            // æ ¹æ“šé¡å‹æ·»åŠ ç«¯å£
            if (type !== 'start') {
                const inputPort = document.createElement('div');
                inputPort.className = 'port input';
                inputPort.onmouseup = (e) => endConnection(e, id, 'input');
                nodeEl.appendChild(inputPort);
            }

            if (type !== 'end') {
                const outputPort = document.createElement('div');
                outputPort.className = 'port output';
                outputPort.onmousedown = (e) => startConnection(e, id, 'output');
                nodeEl.appendChild(outputPort);
            }

            // åˆªé™¤æŒ‰éˆ• (å³éµ)
            nodeEl.oncontextmenu = (e) => {
                e.preventDefault();
                if(confirm('ç¢ºå®šè¦åˆªé™¤æ­¤ç¯€é»å—ï¼Ÿ')) {
                    deleteNode(id);
                }
            };

            canvas.appendChild(nodeEl);
            nodes.push({ id, x, y, type, title, el: nodeEl });
        }

        // --- 3. æ‹–æ›³ç§»å‹•ç¯€é»é‚è¼¯ ---
        let currentDragNodeId = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        function startDragNode(e, nodeId) {
            e.stopPropagation(); // é˜²æ­¢è§¸ç™¼ç•«å¸ƒé»æ“Š
            currentDragNodeId = nodeId;
            const node = nodes.find(n => n.id === nodeId);
            const rect = node.el.getBoundingClientRect();
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;

            document.addEventListener('mousemove', moveNode);
            document.addEventListener('mouseup', stopDragNode);
        }

        function moveNode(e) {
            if (!currentDragNodeId) return;
            
            const node = nodes.find(n => n.id === currentDragNodeId);
            const canvasRect = canvas.getBoundingClientRect();
            
            let newX = e.clientX - canvasRect.left - dragOffsetX;
            let newY = e.clientY - canvasRect.top - dragOffsetY;

            // æ›´æ–° DOM
            node.el.style.left = `${newX}px`;
            node.el.style.top = `${newY}px`;
            node.x = newX;
            node.y = newY;

            // æ›´æ–°ç›¸é—œé€£ç·š
            updateConnections();
        }

        function stopDragNode() {
            currentDragNodeId = null;
            document.removeEventListener('mousemove', moveNode);
            document.removeEventListener('mouseup', stopDragNode);
        }

        // --- 4. é€£ç·šé‚è¼¯ (Bezier Curves) ---
        function startConnection(e, nodeId, type) {
            e.stopPropagation();
            e.preventDefault(); // é˜²æ­¢é¸å–æ–‡å­—
            isDrawing = true;
            
            const rect = e.target.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            
            startPort = {
                nodeId: nodeId,
                x: rect.left + rect.width / 2 - canvasRect.left,
                y: rect.top + rect.height / 2 - canvasRect.top,
                el: e.target
            };

            // å‰µå»ºè‡¨æ™‚ç·šæ¢
            tempLine = document.createElementNS("http://www.w3.org/2000/svg", "path");
            tempLine.setAttribute("class", "connection-line");
            tempLine.setAttribute("stroke-dasharray", "5,5"); // è™›ç·šè¡¨ç¤ºæ­£åœ¨æ‹–æ›³
            svgLayer.appendChild(tempLine);

            document.addEventListener('mousemove', drawTempLine);
            document.addEventListener('mouseup', abortConnection);
        }

        function drawTempLine(e) {
            if (!isDrawing) return;
            const canvasRect = canvas.getBoundingClientRect();
            const endX = e.clientX - canvasRect.left;
            const endY = e.clientY - canvasRect.top;
            
            // ç¹ªè£½è²èŒ²æ›²ç·š
            const d = getBezierPath(startPort.x, startPort.y, endX, endY);
            tempLine.setAttribute("d", d);
        }

        function endConnection(e, targetNodeId, type) {
            if (!isDrawing) return;
            e.stopPropagation();

            if (startPort.nodeId === targetNodeId) {
                console.log("ä¸èƒ½é€£æ¥è‡ªå·±");
                return; // ä¸èƒ½é€£è‡ªå·±
            }

            // æª¢æŸ¥æ˜¯å¦é‡è¤‡é€£ç·š
            const exists = connections.find(c => c.from === startPort.nodeId && c.to === targetNodeId);
            if (exists) return;

            // å‰µå»ºæ­£å¼é€£ç·š
            connections.push({
                id: `conn-${Date.now()}`,
                from: startPort.nodeId,
                to: targetNodeId,
                fromPortEl: startPort.el,
                toPortEl: e.target
            });

            updateConnections();
            
            // æ¸…ç†ç‹€æ…‹
            cleanUpTempLine();
        }

        function abortConnection() {
            cleanUpTempLine();
        }

        function cleanUpTempLine() {
            isDrawing = false;
            if (tempLine) {
                tempLine.remove();
                tempLine = null;
            }
            startPort = null;
            document.removeEventListener('mousemove', drawTempLine);
            document.removeEventListener('mouseup', abortConnection);
        }

        // --- 5. ç¹ªè£½èˆ‡æ›´æ–°æ‰€æœ‰é€£ç·š ---
        function updateConnections() {
            // æ¸…ç©º SVG (é™¤äº† tempLine)
            const lines = Array.from(svgLayer.querySelectorAll('.connection-line:not([stroke-dasharray])'));
            lines.forEach(l => l.remove());

            const canvasRect = canvas.getBoundingClientRect();

            connections.forEach(conn => {
                const fromRect = conn.fromPortEl.getBoundingClientRect();
                const toRect = conn.toPortEl.getBoundingClientRect();

                const x1 = fromRect.left + fromRect.width / 2 - canvasRect.left;
                const y1 = fromRect.top + fromRect.height / 2 - canvasRect.top;
                const x2 = toRect.left + toRect.width / 2 - canvasRect.left;
                const y2 = toRect.top + toRect.height / 2 - canvasRect.top;

                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute("class", "connection-line");
                path.setAttribute("d", getBezierPath(x1, y1, x2, y2));
                
                // é»æ“Šç·šæ¢åˆªé™¤
                path.onclick = (e) => {
                    e.stopPropagation();
                    if(confirm("åˆªé™¤é€™æ¢é€£ç·š?")) {
                        connections = connections.filter(c => c.id !== conn.id);
                        updateConnections();
                    }
                };
                
                svgLayer.appendChild(path);
            });
        }

        function getBezierPath(x1, y1, x2, y2) {
            // è¨ˆç®—æ§åˆ¶é»ï¼Œè®“ç·šæ¢æ°´å¹³å½æ›² (é¡ä¼¼ Node-RED é¢¨æ ¼)
            const curvature = 0.5;
            const hx1 = x1 + Math.abs(x2 - x1) * curvature;
            const hx2 = x2 - Math.abs(x2 - x1) * curvature;
            return `M ${x1} ${y1} C ${hx1} ${y1} ${hx2} ${y2} ${x2} ${y2}`;
        }

        // --- 6. å…¶ä»–åŠŸèƒ½ ---
        function deleteNode(nodeId) {
            // ç§»é™¤ DOM
            const node = nodes.find(n => n.id === nodeId);
            if(node) node.el.remove();
            
            // ç§»é™¤æ•¸æ“š
            nodes = nodes.filter(n => n.id !== nodeId);
            
            // ç§»é™¤ç›¸é—œé€£ç·š
            connections = connections.filter(c => c.from !== nodeId && c.to !== nodeId);
            
            updateConnections();
        }

        function clearCanvas() {
            nodes.forEach(n => n.el.remove());
            nodes = [];
            connections = [];
            nextNodeId = 1;
            updateConnections();
        }

        function exportFlow() {
            // æº–å‚™ç™¼é€çµ¦ Flask çš„è³‡æ–™çµæ§‹
            const flowData = {
                nodes: nodes.map(n => ({ 
                    id: n.id, 
                    type: n.type, 
                    title: n.title, 
                    position: { x: n.x, y: n.y },
                    config: {} // æœªä¾†å¯æ”¾åƒæ•¸
                })),
                connections: connections.map(c => ({
                    from: c.from,
                    to: c.to
                }))
            };
            
            showModal(JSON.stringify(flowData, null, 2));
            // åœ¨å¯¦éš› Flask æ‡‰ç”¨ä¸­ï¼Œé€™è£¡æœƒç”¨ fetch('/api/save_flow', ...)
        }

        function runSimulation() {
            const flowData = {
                nodes: nodes.map(n => ({ id: n.id, type: n.type, title: n.title })),
                connections: connections.map(c => ({ from: c.from, to: c.to }))
            };

            // ç°¡å–®çš„æ‹“æ’²æ’åºæ¨¡æ“¬ (åªæ‰¾ Start ç¯€é»å¾€ä¸‹è·‘)
            let logs = "æ¨¡æ“¬åŸ·è¡Œæ—¥èªŒ:\n------------------\n";
            const startNodes = flowData.nodes.filter(n => n.type === 'start');
            
            if (startNodes.length === 0) {
                logs += "éŒ¯èª¤: æ²’æœ‰æ‰¾åˆ°é–‹å§‹ç¯€é» (Start Node)";
            } else {
                startNodes.forEach(startNode => {
                    logs += `[åŸ·è¡Œ] ç¯€é» ${startNode.title} (${startNode.id})\n`;
                    
                    // ç°¡å–®çš„éæ­¸å°‹æ‰¾ä¸‹ä¸€å±¤
                    let currentId = startNode.id;
                    let nextConn = flowData.connections.find(c => c.from === currentId);
                    
                    while(nextConn) {
                        const nextNode = flowData.nodes.find(n => n.id === nextConn.to);
                        if (!nextNode) break;
                        logs += `  â†“\n[åŸ·è¡Œ] ç¯€é» ${nextNode.title} (${nextNode.id})\n`;
                        currentId = nextNode.id;
                        nextConn = flowData.connections.find(c => c.from === currentId);
                    }
                    logs += "  â†“\n[çµæŸ] æµç¨‹çµæŸ\n\n";
                });
            }

            showModal(logs);
        }

        // Modal UI
        function showModal(content) {
            const modal = document.getElementById('modal');
            const contentEl = document.getElementById('modal-content');
            contentEl.textContent = content;
            modal.classList.remove('hidden');
        }

        function closeModal() {
            document.getElementById('modal').classList.add('hidden');
        }

    </script>
</body>
</html>