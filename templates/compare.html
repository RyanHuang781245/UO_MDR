{% extends "base.html" %}
{% block content %}
<h1 class="h4 mb-3">來源比對</h1>
<div class="row g-3">
  <div class="col-md-8">
    <iframe id="htmlFrame" src="{{ html_url }}" style="width:100%; height:80vh;" class="border"></iframe>
  </div>
  <div class="col-md-4">
    <ul id="sourceList" class="list-group"></ul>
    <div class="mt-3">
      <a class="btn btn-secondary" href="{{ back_link }}">返回結果</a>
    </div>
  </div>
</div>
<script>
const CHAPTER_SOURCES = {{ chapter_sources|tojson }};
const CHAPTERS = {{ chapters|tojson }};
const COLORS = ['#ffb3ba','#baffc9','#bae1ff','#ffdfba','#ffffba','#baffff','#f4baff'];
const CHAPTER_SET = new Set(CHAPTERS);
let highlighted = [];
let captured = [];

function clearHighlights() {
  highlighted.forEach(el => {
    el.style.backgroundColor = '';
  });
  highlighted = [];
}

function updateSources(ch) {
  clearHighlights();
  const list = document.getElementById('sourceList');
  list.innerHTML = '';
  let sequence = [];
  if (Array.isArray(ch)) {
    sequence = ch.slice();
  } else if (ch === null) {
    const all = Object.values(CHAPTER_SOURCES).flat();
    sequence = all.slice();
  } else {
    sequence = CHAPTER_SOURCES[ch] || [];
  }
  if (!sequence.length) return;

  const uniqueSources = [...new Set(sequence)];
  const colorMap = {};
  let colorIdx = 0;
  let pdfColor = null;
  uniqueSources.forEach(src => {
    let color;
    if (src.toLowerCase().endsWith('.pdf')) {
      if (!pdfColor) {
        pdfColor = COLORS[colorIdx % COLORS.length];
        colorIdx++;
      }
      color = pdfColor;
    } else {
      color = COLORS[colorIdx % COLORS.length];
      colorIdx++;
    }
    colorMap[src] = color;
    const li = document.createElement('li');
    li.className = 'list-group-item';
    li.textContent = src;
    li.style.backgroundColor = color;
    list.appendChild(li);
  });

  if (typeof ch === 'string') {
    const blocks = captured.filter(([sec]) => sec === ch).map(([,node]) => node);
    let idx = 0;
    const markers = sequence.map(src => {
      const title = src.match(/標題\s*(.+)/);
      if (title) return {type: 'title', value: title[1]};
      const sec = src.match(/章節\s*([\d\.]+)/);
      return sec ? {type: 'section', value: sec[1]} : null;
    });
    const findNextMarkerIdx = from => {
      for (let i = from + 1; i < markers.length; i++) {
        if (markers[i]) return i;
      }
      return -1;
    };
    let nextIdx = findNextMarkerIdx(0);
    let nextMarker = nextIdx !== -1 ? markers[nextIdx] : null;
    blocks.forEach(node => {
      const text = node.textContent.trim();
      if (nextMarker && highlighted.length && (
          (nextMarker.type === 'section' && text.startsWith(nextMarker.value)) ||
          (nextMarker.type === 'title' && text.includes(nextMarker.value))
        )) {
        idx = nextIdx;
        nextIdx = findNextMarkerIdx(idx);
        nextMarker = nextIdx !== -1 ? markers[nextIdx] : null;
      }
      const src = sequence[idx] || sequence[sequence.length - 1];
      node.style.backgroundColor = colorMap[src];
      highlighted.push(node);
      if (markers[idx] && markers[idx].type === 'title') {
        idx = nextIdx;
        nextIdx = findNextMarkerIdx(idx);
        nextMarker = nextIdx !== -1 ? markers[nextIdx] : null;
      }
    });
  }
}

const iframe = document.getElementById('htmlFrame');
iframe.addEventListener('load', () => {
  const doc = iframe.contentDocument || iframe.contentWindow.document;
  captured = [];
  const foundChapters = new Set();
  let current_section = null;
  Array.from(doc.body.children).forEach(node => {
    const text = node.textContent.trim();
    if (CHAPTER_SET.has(text)) {
      current_section = text;
      foundChapters.add(text);
      node.style.cursor = 'pointer';
      node.addEventListener('click', () => updateSources(text));
    } else {
      captured.push([current_section, node]);
    }
  });
  let unhandled = [];
  CHAPTERS.forEach(ch => {
    if (!foundChapters.has(ch)) {
      unhandled = unhandled.concat(CHAPTER_SOURCES[ch] || []);
    }
  });
  if (unhandled.length) {
    updateSources(unhandled);
  } else if (!foundChapters.size) {
    updateSources(null);
  }
});
</script>
{% endblock %}
