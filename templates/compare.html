{% extends "base.html" %}
{% block content %}
<h1 class="h4 mb-3">來源比對</h1>
<div class="row g-3">
  <div class="col-md-8">
    <iframe id="htmlFrame" src="{{ html_url }}" style="width:100%; height:80vh;" class="border"></iframe>
  </div>
  <div class="col-md-4">
    <ul id="sourceList" class="list-group"></ul>
    <div class="mt-3">
      <div class="d-flex gap-2">
        <button id="modeBtn" class="btn btn-outline-secondary" type="button">編輯模式</button>
        <button id="saveBtn" class="btn btn-primary" type="button">保存</button>
        <button id="downloadBtn" class="btn btn-success" type="button">下載</button>
        <a class="btn btn-secondary" href="{{ back_link }}">返回結果</a>
      </div>
      <span id="saveStatus" class="d-block mt-2">已保存</span>
    </div>
  </div>
</div>

<div class="modal fade" id="sourceModal" tabindex="-1">
  <div class="modal-dialog modal-xl">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">來源檔案預覽</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body p-0"></div>
    </div>
  </div>
</div>
<script>
const CHAPTER_SOURCES = {{ chapter_sources|tojson }};
const CHAPTERS = {{ chapters|tojson }};
const SOURCE_URLS = {{ source_urls|tojson }};
const COLORS = ['#ffb3ba','#baffc9','#bae1ff','#ffdfba','#ffffba','#baffff','#f4baff'];
const CHAPTER_SET = new Set(CHAPTERS);
const SOURCE_COLOR_MAP = {};
let colorIndex = 0;
let highlighted = [];

function openWindow(url) {
  window.open(url, '_blank', 'width=1200,height=800,scrollbars=yes,resizable=yes');
}

function getColorForSource(source) {
  if (!source) {
    return null;
  }
  if (!Object.prototype.hasOwnProperty.call(SOURCE_COLOR_MAP, source)) {
    SOURCE_COLOR_MAP[source] = COLORS[colorIndex % COLORS.length];
    colorIndex += 1;
  }
  return SOURCE_COLOR_MAP[source];
}

function extractSection(label) {
  if (!label) return '';
  const match = label.match(/章節\s*([\d\.]+)/);
  return match ? match[1].trim() : '';
}

function extractTitle(label) {
  if (!label) return '';
  const match = label.match(/標題\s*(.+)/);
  return match ? match[1].trim() : '';
}

function normalizeEntry(entry) {
  if (!entry) {
    return {label: '', source: '', section: '', title: ''};
  }
  if (typeof entry === 'string') {
    return {
      label: entry,
      source: entry,
      section: extractSection(entry),
      title: extractTitle(entry),
    };
  }
  const label = entry.label || '';
  const source = entry.source || label;
  return {
    label,
    source,
    section: entry.section || extractSection(label),
    title: entry.title || extractTitle(label),
  };
}

Object.values(CHAPTER_SOURCES).forEach(items => {
  items.forEach(item => {
    const meta = normalizeEntry(item);
    getColorForSource(meta.source);
  });
});

function clearHighlights() {
  highlighted.forEach(el => {
    el.style.backgroundColor = '';
  });
  highlighted = [];
}

function updateSources(ch, element) {
  clearHighlights();
  const list = document.getElementById('sourceList');
  list.innerHTML = '';
  let sequence = [];
  if (Array.isArray(ch)) {
    sequence = ch.slice();
  } else if (ch === null) {
    const all = Object.values(CHAPTER_SOURCES).flat();
    sequence = all.slice();
  } else {
    sequence = CHAPTER_SOURCES[ch] || [];
  }
  if (!sequence.length) return;

  const metaSequence = sequence.map(normalizeEntry);
  const uniqueEntries = [];
  const seenLabels = new Set();
  metaSequence.forEach(meta => {
    if (!meta.label || seenLabels.has(meta.label)) {
      return;
    }
    seenLabels.add(meta.label);
    uniqueEntries.push(meta);
  });

  uniqueEntries.forEach(meta => {
    const li = document.createElement('li');
    li.className = 'list-group-item';
    li.textContent = meta.label;
    const color = getColorForSource(meta.source);
    if (color) {
      li.style.backgroundColor = color;
    }
    const url = SOURCE_URLS[meta.label];
    if (url) {
      li.style.cursor = 'pointer';
      li.addEventListener('click', () => openWindow(url));
    }
    list.appendChild(li);
  });

  if (element && metaSequence.length) {
    let node = element.nextElementSibling;
    let idx = 0;
    const markers = metaSequence.map(meta => {
      if (meta.title) {
        return {type: 'title', value: meta.title};
      }
      if (meta.section) {
        return {type: 'section', value: meta.section};
      }
      return null;
    });
    const findNextMarkerIdx = from => {
      for (let i = from + 1; i < markers.length; i++) {
        if (markers[i]) return i;
      }
      return -1;
    };
    let nextIdx = findNextMarkerIdx(0);
    let nextMarker = nextIdx !== -1 ? markers[nextIdx] : null;
    while (node && !CHAPTER_SET.has(node.textContent.trim())) {
      const text = node.textContent.trim();
      if (
        nextMarker &&
        highlighted.length &&
        ((nextMarker.type === 'section' && text.startsWith(nextMarker.value)) ||
          (nextMarker.type === 'title' && text.includes(nextMarker.value)))
      ) {
        idx = nextIdx;
        nextIdx = findNextMarkerIdx(idx);
        nextMarker = nextIdx !== -1 ? markers[nextIdx] : null;
      }
      const meta = metaSequence[idx] || metaSequence[metaSequence.length - 1];
      const color = getColorForSource(meta.source);
      if (color) {
        node.style.backgroundColor = color;
      }
      highlighted.push(node);
      node = node.nextElementSibling;
    }
  }
}

const iframe = document.getElementById('htmlFrame');
let doc;
let isSaved = true;
const statusEl = document.getElementById('saveStatus');
function setSaved(saved) {
  isSaved = saved;
  statusEl.textContent = saved ? '已保存' : '未保存';
  statusEl.classList.toggle('text-success', saved);
  statusEl.classList.toggle('text-danger', !saved);
}
setSaved(true);

iframe.addEventListener('load', () => {
  doc = iframe.contentDocument || iframe.contentWindow.document;
  doc.designMode = 'off';
  doc.addEventListener('input', () => setSaved(false));
  let found = false;
  let unhandled = [];
  CHAPTERS.forEach(ch => {
    const elements = Array.from(doc.body.querySelectorAll('*')).filter(el => el.textContent.trim() === ch);
    if (elements.length) {
      found = true;
      elements.forEach(el => {
        el.style.cursor = 'pointer';
        el.addEventListener('click', () => updateSources(ch, el));
      });
    } else {
      unhandled = unhandled.concat(CHAPTER_SOURCES[ch] || []);
    }
  });
  if (unhandled.length) {
    updateSources(unhandled);
  } else if (!found) {
    updateSources(null);
  }
});

document.getElementById('modeBtn').addEventListener('click', () => {
  if (!doc) return;
  if (doc.designMode === 'on') {
    doc.designMode = 'off';
    document.getElementById('modeBtn').textContent = '編輯模式';
  } else {
    doc.designMode = 'on';
    document.getElementById('modeBtn').textContent = '檢視模式';
  }
});

function saveHtml() {
  const html = (iframe.contentDocument || iframe.contentWindow.document).documentElement.outerHTML;
  return fetch('{{ save_url }}', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({html})
  });
}

document.getElementById('saveBtn').addEventListener('click', () => {
  saveHtml().then(r => {
    if (r.ok) {
      setSaved(true);
      alert('已保存');
    } else {
      alert('保存失敗');
    }
  });
});

document.getElementById('downloadBtn').addEventListener('click', () => {
  if (!isSaved) {
    alert('請先保存才可下載');
    return;
  }
  window.location = '{{ download_url }}';
});
</script>
{% endblock %}
